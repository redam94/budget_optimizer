[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "budget_optimizer",
    "section": "",
    "text": "This library is to help wrap custom models for use in budget optimization. It is designed to work with nested MMMs, where the budget is allocated to different media channels and the performance is measured by multiple KPIs which are fed into a downstream revenue model.\nFor example in a typical MMM, the budget is allocated to different media channels and the performance is measured by sales, website visits, and brand awareness. Website visits and brand awareness impact sales, website visits are impacted by brand awareness. So the effects of changing the budget flow through the nested KPIs.\nThe library is designed to work with any model that can be wrapped in a Model class. The Model class should have needs a predict method that takes a dictionary of parameters and returns an xarray dataset with the model prediction for that model’s kpi. These model classes can be composed in a NestedModel class which will flow the predictions into the next stage of the model.\nModel loading and functions to define how budget translates into model inputs must be defined in a seperate file. Included in the folder with the model artifacts in a file called model_config.py which should contain the following functions:",
    "crumbs": [
      "budget_optimizer"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "budget_optimizer",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall budget_optimizer in Development mode\n# make sure budget_optimizer package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to budget_optimizer\n$ nbdev_prepare",
    "crumbs": [
      "budget_optimizer"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "budget_optimizer",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/redam94/budget_optimizer.git\nor from pypi\n$ pip install budget_optimizer\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "budget_optimizer"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "budget_optimizer",
    "section": "How to use",
    "text": "How to use\n\nStep 1: Create a model_config.py file\nThis contains the functions to load the model and convert the budget into model inputs. This allows models to be updated without changing the code in the budget_optimizer library.\n## file: example_files/fast_model/model_config.py\nimport xarray as xr\nfrom pathlib import Path\nimport numpy as np\nfrom budget_optimizer.utils.model_helpers import AbstractModel, BudgetType\n\nINITIAL_BUDGET: BudgetType = dict(a=2., b=3.)\n\nclass SimpleModel(AbstractModel):\n  \"\"\"\n  Simple model that just adds the two variables a and b.\n  This can be as complex as you want as long as it has a predict method\n  that takes an xarray Dataset and returns an xarray DataArray and \n  a contributions method that takes an xarray Dataset and returns an xarray Dataset.\n  \n  Ideally, the model should also have data that defines the initial data that the\n  model was trained on. You can wrap cutom models or functions in a class like this.\n  \"\"\"\n  def __init__(self, data: xr.Dataset = None):\n    self.data = data\n    \n  def predict(self, x: xr.Dataset) -&gt; xr.DataArray:\n    x = x.copy()\n    x[\"prediction\"] = np.exp(1 + .2*(x[\"a\"]**2/(x[\"a\"]**2 + np.exp(1)**2)) + .25*(x[\"b\"]**4/(x[\"b\"]**4 + np.exp(2)**4)))\n    return x[\"prediction\"]\n  \n  def contributions(self, x: xr.Dataset) -&gt; xr.Dataset:\n    return x\n\ndef budget_to_data(budget: BudgetType, model: AbstractModel) -&gt; xr.Dataset:\n    data = model.data.copy()\n    for key, value in budget.items():\n        data[key] = value/INITIAL_BUDGET[key]*data[key]\n    return data\n  \ndef model_loader(path: Path) -&gt; AbstractModel:\n    rng = np.random.default_rng(42)\n    data_a = xr.DataArray(np.exp(1+rng.normal(0, .4, size=156)), dims='time', coords={\"time\": np.arange(1, 157)})\n    data_b = xr.DataArray(np.exp(2+rng.normal(0, .2, size=156)), dims='time', coords={\"time\": np.arange(1, 157)})\n    return SimpleModel(data = xr.Dataset({\"a\": data_a, \"b\": data_b}))\n\n\nStep 2: Create a budget model\nThis is a class that wraps the model and defines how the budget is allocated to the model inputs. It also tracks model names and kpis for future use.\n\nclass RevenueModel(BaseBudgetModel):\n    def __init__(self, model_name: str, model_kpi: str, model_path: str):\n        super().__init__(model_name, model_kpi, model_path)\n\nInitialize the model with the path to the model artifacts, model name, and kpi name.\n\nMODEL_NAME = \"Revenue Model\"\nMODEL_KPI = \"Revenue\"\nMODEL_PATH = \"../example_files/fast_model\"\nmodel = RevenueModel(MODEL_NAME, MODEL_KPI, MODEL_PATH)\nbudget_1 = dict(a=2, b=3)\nbudget_2 = dict(a=2.3, b=2.7)\noutcome_budget_1 = model.predict(budget_1)\noutcome_budget_2 = model.predict(budget_2)\n\nWe can now use the model to predict the kpi for a given budget.\n\n\n\n\n\n\n\n\nFigure 1: Revenue Performance of Budget 1 and Budget 2\n\n\n\n\n\n\n\nStep 3: Create the Optimizer Config Files\nThis is a file that defines the loss function for the optimization problem. It should contain a function named loss_fn that takes the predriction from the model and kwargs and returns a scalar loss to minimize.\n## file: example_files/optimizer_config.py\nimport numpy as np\nimport xarray as xr\nfrom budget_optimizer.utils.model_helpers import BudgetType, load_yaml\nfrom pathlib import Path\n\n# Define the optimizer configuration\nCONFIG = load_yaml(Path(__file__).parent / \"optimizer_config.yaml\")\n\ndef loss_fn(x: xr.DataArray, start_date=None, end_date=None, dim=\"Period\"):\n    # x is a numpy array of shape (n_params,)\n    # start_date and end_date are datetime objects\n    # return a scalar loss\n    x = x.sel({dim: slice(start_date, end_date)})\n    return -np.sum(x)\n\ndef optimizer_array_to_budget(array: np.ndarray) -&gt; BudgetType:\n    initial_budget: BudgetType = CONFIG['initial_budget']\n    budget: BudgetType = {}\n        \n    for i, key in enumerate(initial_budget.keys()):\n        budget[key] = array[i]\n    return budget\nAn additional file will be used define the kwargs for the loss function and the initial budget.\ninitial_budget:\n  a: 2\n  b: 3\nloss_fn_kwargs:\n  start_date: null\n  end_date: null\n  dim: \"time\"\n\n\nStep 4: Create the Optimizer\nInstantiate the optimizer and define the initial position, bounds and constraints for the optimization problem.\n\ninit_budget = np.array([2, 3])\nbounds = [(1.7, 2.3), (2.7, 3.3)]\nconstraints = opt.LinearConstraint([[1, 1]], [5], [5])\noptimizer = ScipyBudgetOptimizer(model, \"../example_files\")\n\n\n\nStep 5: Run the optimization\n\nfitted_optimizer = optimizer.optimize(bounds, constraints, init_pos=init_budget)\n\n\nfitted_optimizer.optimal_budget\n\n{'a': np.float64(1.7002367944276708), 'b': np.float64(3.2997632055723294)}\n\n\n\n\n\n\n\n\n\n\nFigure 2: Revenue Performance of Budget 1 and Budget 2",
    "crumbs": [
      "budget_optimizer"
    ]
  },
  {
    "objectID": "utils/search_space_helpers.html",
    "href": "utils/search_space_helpers.html",
    "title": "Constrained Search Space",
    "section": "",
    "text": "source\n\nTrial\n\n Trial (*args, **kwargs)\n\nProtocol for a trial object\n\nsource\n\n\nConstrainedSearchSpace\n\n ConstrainedSearchSpace (bounds:dict[str,tuple[float,float]],\n                         constraint:tuple[float,float])\n\nA class that generates a search space with constraints\n\nsource\n\n\nConstrainedSearchSpace.__call__\n\n ConstrainedSearchSpace.__call__ (trial:__main__.Trial)\n\nSample from constrained search space\n\n\n\n\nType\nDetails\n\n\n\n\ntrial\nTrial\ntrial object\n\n\nReturns\ndict\nselected budget\n\n\n\n\nclass TestTrial:\n    @staticmethod\n    def suggest_float(name: str, low: float, high: float, **kwargs) -&gt; float:\n        return np.random.uniform(low, high)\n\n\nRNG = np.random.default_rng(44)\nactual_spends = np.exp(RNG.normal(7, 2, 5)) # generate some random spends\nbounds = {f\"dim_{dim}\": (np.round(.8*spend, 2), np.round(1.2*spend, 2)) for dim, spend in enumerate(actual_spends)} # generate bounds for each spend\ntotal_spend = sum(actual_spends) # calculate the total spend\nconstraint = (total_spend, total_spend) # set the constraint to be the total spend\ntrial = TestTrial() # creates a mock trial\nsearch_space = ConstrainedSearchSpace(bounds=bounds, constraint=constraint) # create the search space\nselected_budget = search_space(trial) # get the first sample\nfor name, sample in selected_budget.items(): # iterate over the sample\n    print(f\"Sample {name}: {sample:.2f}, Bound {name}: {bounds[name]}\") # print the sample and the bound\nprint(f\"Sample Total: {sum(selected_budget.values()):.2f}, Total: {total_spend:.2f}\") # print the total of the sample and the total spend\n\nSample dim_1: 1297.19, Bound dim_1: (1076.5, 1614.74)\nSample dim_2: 2059.89, Bound dim_2: (1686.42, 2529.63)\nSample dim_4: 5580.39, Bound dim_4: (4561.22, 6841.82)\nSample dim_3: 12345.41, Bound dim_3: (8516.67, 12775.01)\nSample dim_0: 18288.21, Bound dim_0: (15816.07, 23724.11)\nSample Total: 39571.09, Total: 39571.09",
    "crumbs": [
      "utils",
      "Constrained Search Space"
    ]
  },
  {
    "objectID": "optimizer.html",
    "href": "optimizer.html",
    "title": "Optimizer",
    "section": "",
    "text": "source\n\nBaseOptimizer\n\n BaseOptimizer\n                (model:budget_optimizer.utils.model_classes.BaseBudgetMode\n                l, config_path:str|pathlib.Path)\n\nOptimizer wrapper for the pyswarms package\n\n\n\n\nType\nDetails\n\n\n\n\nmodel\nBaseBudgetModel\nThe model to optimize\n\n\nconfig_path\nstr | pathlib.Path\nPath to the configuration files\n\n\n\n\nsource\n\n\nScipyBudgetOptimizer\n\n ScipyBudgetOptimizer\n                       (model:budget_optimizer.utils.model_classes.BaseBud\n                       getModel, config_path:str|pathlib.Path)\n\nOptimizer wrapper for the pyswarms package\n\n\n\n\nType\nDetails\n\n\n\n\nmodel\nBaseBudgetModel\nThe model to optimize\n\n\nconfig_path\nstr | pathlib.Path\nPath to the configuration files\n\n\n\n\nclass BudgetModel(BaseBudgetModel):\n    \"\"\"\n    Budget model class\n    \"\"\"\n    ...\n\n\nfast_model = BudgetModel(\"Revenue Model\", \"Revenue\", \"../example_files/fast_model\")\n\n\ninit_budget = np.array([2, 3])\nbounds = [(3, 5), (3, 5)]\nconstraints = opt.LinearConstraint([[1, 1]], [8], [8])\no = ScipyBudgetOptimizer(fast_model, \"../example_files\")\n\n\nsource\n\n\nScipyBudgetOptimizer.optimize\n\n ScipyBudgetOptimizer.optimize (bounds:list[tuple[float,float]],\n                                constraints:None|scipy.optimize._constrain\n                                ts.LinearConstraint,\n                                init_pos:numpy.ndarray)\n\nOptimize the model\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nbounds\nlist\nBounds for the optimizer\n\n\nconstraints\nNone | scipy.optimize._constraints.LinearConstraint\nConstraints for the optimizer\n\n\ninit_pos\nndarray\nInitial position of the optimizer\n\n\n\n\no_fitted = o.optimize(bounds, constraints, init_pos=init_budget)\n\n\n\n           message: `gtol` termination condition is satisfied.\n           success: True\n            status: 1\n               fun: -601.6849021505009\n                 x: [ 3.168e+00  4.832e+00]\n               nit: 15\n              nfev: 30\n              njev: 10\n              nhev: 0\n          cg_niter: 9\n      cg_stop_cond: 1\n              grad: [-1.485e+01 -1.485e+01]\n   lagrangian_grad: [-9.561e-09  9.561e-09]\n            constr: [array([ 8.000e+00]), array([ 3.168e+00,  4.832e+00])]\n               jac: [array([[ 1.000e+00,  1.000e+00]]), array([[ 1.000e+00,  0.000e+00],\n                           [ 0.000e+00,  1.000e+00]])]\n       constr_nfev: [0, 0]\n       constr_njev: [0, 0]\n       constr_nhev: [0, 0]\n                 v: [array([ 1.485e+01]), array([-1.731e-04,  1.731e-04])]\n            method: tr_interior_point\n        optimality: 9.56122952780968e-09\n  constr_violation: 0.0\n    execution_time: 0.0405728816986084\n         tr_radius: 29797.67905015749\n    constr_penalty: 1.0\n barrier_parameter: 3.200000000000001e-05\n barrier_tolerance: 3.200000000000001e-05\n             niter: 15\n\n\n\n\nOptimal budget:\n{'a': 3.17, 'b': 4.83}\n\n\n\nsource\n\n\nOptunaBudgetOptimizer\n\n OptunaBudgetOptimizer\n                        (model:budget_optimizer.utils.model_classes.BaseBu\n                        dgetModel, config_path:str|pathlib.Path,\n                        objective_name:str='loss',\n                        storage:str='sqlite:///db.sqlite3', direction:Lite\n                        ral['maximize','minimize']='maximize',\n                        sampler:optuna.samplers._base.BaseSampler=&lt;class\n                        'optuna.samplers._tpe.sampler.TPESampler'&gt;,\n                        pruner:optuna.pruners._base.BasePruner|None=None,\n                        tol:float=0.001, percent_out_tolerance:float=0.1,\n                        sampler_kwargs:dict|None=None,\n                        pruner_kwargs:dict|None=None)\n\nOptimizer wrapper for the pyswarms package\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodel\nBaseBudgetModel\n\nThe model to optimize\n\n\nconfig_path\nstr | pathlib.Path\n\nPath to the configuration files\n\n\nobjective_name\nstr\nloss\nName of the objective\n\n\nstorage\nstr\nsqlite:///db.sqlite3\nStorage for the optimization defaults to local sqlite\n\n\ndirection\nLiteral\nmaximize\nDirection of the optimization\n\n\nsampler\nBaseSampler\nTPESampler\nSampler for the optimization\n\n\npruner\noptuna.pruners._base.BasePruner | None\nNone\nPruner for the optimization\n\n\ntol\nfloat\n0.001\nTolerance for the constraints\n\n\npercent_out_tolerance\nfloat\n0.1\nPercentage of the budget trials that can be outside the constraints\n\n\nsampler_kwargs\ndict | None\nNone\nAdditional arguments for the sampler\n\n\npruner_kwargs\ndict | None\nNone\nAdditional arguments for the pruner\n\n\n\n\n#load_dotenv()\n#USER = os.environ.get(\"POSTGRES_USER\", \"\")\n#PASSWORD = os.environ.get(\"POSTGRES_PASSWORD\", \"\")\n#POSTGRES_URL = f\"postgresql://{USER}:{PASSWORD}@localhost:54320\"\nPOSTGRES_URL = \"sqlite:///db.sqlite3\"\n\n\n#conn = await asyncpg.connect(POSTGRES_URL)\n#database = \"budget_optimizer\"\n#try:\n#    db_exists = await conn.fetchval(\n#                'SELECT 1 FROM pg_database WHERE datname = $1', database\n#                )\n#    print(db_exists)\n#    if not db_exists:\n#        await conn.execute(f'CREATE DATABASE {database}')\n#except Exception as e:\n#    print(e)\n#conn.close()\n#POSTGRES_URL = f\"{POSTGRES_URL}/{database}\"\n\n\noptuna.logging.set_verbosity(optuna.logging.WARNING)\noptuna.logging.get_logger(\"optuna\").addHandler(logging.StreamHandler(sys.stdout))\nslow_model = BudgetModel(\"Revenue Model\", \"Revenue\", \"../example_files/slow_model\")\nopt_optimizer = OptunaBudgetOptimizer(\n  slow_model, \"../example_files\",\n  storage=(POSTGRES_URL),\n  direction=\"maximize\", tol=1e-3, percent_out_tolerance=0.1,\n  sampler_kwargs={\"multivariate\": True, \"group\": True})\n\n\nsource\n\n\nOptunaBudgetOptimizer.optimize\n\n OptunaBudgetOptimizer.optimize (bounds:dict[str,tuple[float,float]],\n                                 constraints:None|tuple=None,\n                                 timeout:int=60, n_trials:int=100,\n                                 study_name:str='optimizer',\n                                 load_if_exists:bool=False, n_jobs:int=1)\n\nOptimize the model\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nbounds\ndict\n\nBounds for the optimizer\n\n\nconstraints\nNone | tuple\nNone\nConstraints for the optimizer\n\n\ntimeout\nint\n60\nTimeout for the optimization\n\n\nn_trials\nint\n100\nMax number of trials to run\n\n\nstudy_name\nstr\noptimizer\nName of the study\n\n\nload_if_exists\nbool\nFalse\nLoad the study if it exists\n\n\nn_jobs\nint\n1\nNumber of jobs to run in parallel\n\n\n\n\nbounds = {\"a\": (3, 8), \"b\": (3, 5)}\nconstraints = (8, 8)\nnow = datetime.now()\nopt_optimizer.optimize(\n  bounds, constraints, \n  n_trials=200_000, timeout=30,  \n  study_name=f\"Optimization_{now.strftime('%Y%m%d_%H%M%S')}\",\n  n_jobs=4)\n\n\no_fitted.optimal_budget\n\n{'a': 3.1675802082673, 'b': 4.8324197917327005}\n\n\n\n\nScipy Optimal Total Budget 8.0\n\n\n\nopt_optimizer.optimal_budget\n\n{'b': 4.831325789181123, 'a': 3.1686742108188772}\n\n\n\n\nOptuna Optimal Total Budget 8.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{reda,\n  author = {Reda, Matthew},\n  title = {Optimizer},\n  url = {https://optimizer.mattreda.pro/budget_optimizer/optimizer.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nReda, Matthew. n.d. “Optimizer.” https://optimizer.mattreda.pro/budget_optimizer/optimizer.html.",
    "crumbs": [
      "Optimizer"
    ]
  },
  {
    "objectID": "utils/model_classes.html",
    "href": "utils/model_classes.html",
    "title": "Model Classes",
    "section": "",
    "text": "source\n\nBaseBudgetModel\n\n BaseBudgetModel (model_name:str, model_kpi:str,\n                  model_path:str|pathlib.Path)\n\nAbstract class for all models\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmodel_name\nstr\nName used to identify the model\n\n\nmodel_kpi\nstr\nKey performance indicator output by the model predict\n\n\nmodel_path\nstr | pathlib.Path\nPath to the model artifact\n\n\n\n\nclass BudgetModel(BaseBudgetModel):\n    \"\"\"\n    Budget model class\n    \"\"\"\n    ...\n\n\nm = BudgetModel(\"Revenue Model\", \"Revenue\", \"../../example_files/fast_model\")\n\n\nsource\n\n\nBaseBudgetModel.predict\n\n BaseBudgetModel.predict\n                          (budget:Union[Dict[str,float],xarray.core.datase\n                          t.Dataset])\n\nPredict the target variable from the input data\n\n\n\n\nType\nDetails\n\n\n\n\nbudget\nUnion\nBudget\n\n\nReturns\nDataArray\nPredicted target variable\n\n\n\n\nbudget = {\"a\": 2, \"b\": .3}\nprediction = m.predict(budget)\n\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nBaseBudgetModel.contributions\n\n BaseBudgetModel.contributions\n                                (budget:Union[Dict[str,float],xarray.core.\n                                dataset.Dataset])\n\nGet the contributions of the input data to the target variable\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nbudget\nUnion\nBudget\n\n\nReturns\nDataset\nContributions of the input data to the target variable\n\n\n\n\ncontributions = m.contributions(budget)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{reda,\n  author = {Reda, Matthew},\n  title = {Model {Classes}},\n  url = {https://optimizer.mattreda.pro/budget_optimizer/utils/model_classes.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nReda, Matthew. n.d. “Model Classes.” https://optimizer.mattreda.pro/budget_optimizer/utils/model_classes.html.",
    "crumbs": [
      "utils",
      "Model Classes"
    ]
  },
  {
    "objectID": "utils/model_helpers.html",
    "href": "utils/model_helpers.html",
    "title": "Model Helpers",
    "section": "",
    "text": "source\n\n\n\n load_module (module_name:str, module_path:pathlib.Path)\n\nLoad a module from a file path.\n\n\n\n\nType\nDetails\n\n\n\n\nmodule_name\nstr\nThe name of the module to load\n\n\nmodule_path\nPath\nThe path to the module\n\n\nReturns\nobject\nThe loaded module\n\n\n\n\nsource\n\n\n\n\n load_yaml (file_path:pathlib.Path)\n\nLoad a yaml file.\n\n\n\n\nType\nDetails\n\n\n\n\nfile_path\nPath\nThe path to the YAML file\n\n\nReturns\nDict\nThe loaded module",
    "crumbs": [
      "utils",
      "Model Helpers"
    ]
  },
  {
    "objectID": "utils/model_helpers.html#config-loading",
    "href": "utils/model_helpers.html#config-loading",
    "title": "Model Helpers",
    "section": "",
    "text": "source\n\n\n\n load_module (module_name:str, module_path:pathlib.Path)\n\nLoad a module from a file path.\n\n\n\n\nType\nDetails\n\n\n\n\nmodule_name\nstr\nThe name of the module to load\n\n\nmodule_path\nPath\nThe path to the module\n\n\nReturns\nobject\nThe loaded module\n\n\n\n\nsource\n\n\n\n\n load_yaml (file_path:pathlib.Path)\n\nLoad a yaml file.\n\n\n\n\nType\nDetails\n\n\n\n\nfile_path\nPath\nThe path to the YAML file\n\n\nReturns\nDict\nThe loaded module",
    "crumbs": [
      "utils",
      "Model Helpers"
    ]
  },
  {
    "objectID": "utils/model_helpers.html#abstract-classes-and-types",
    "href": "utils/model_helpers.html#abstract-classes-and-types",
    "title": "Model Helpers",
    "section": "Abstract Classes and Types",
    "text": "Abstract Classes and Types\n\nsource\n\nAbstractModel\n\n AbstractModel ()\n\nAn abstract class for models\n\nsource\n\n\nAbstractModel.predict\n\n AbstractModel.predict (x:xarray.core.dataset.Dataset)\n\n\nsource\n\n\nAbstractModel.contributions\n\n AbstractModel.contributions (x:xarray.core.dataset.Dataset)",
    "crumbs": [
      "utils",
      "Model Helpers"
    ]
  }
]